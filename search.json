[{"title":"Hướng dẫn xây dựng gRPC server bằng typescript đơn giản","url":"/Huong-dan-xay-dung-gRPC-server-bang-typescript-don-gian/","content":"<p>Dạo này mình làm một dự án microservices và có gặp phải các vấn đề về giao tiếp giữa các service trong khối microservices với nhau. Sau thời gian nghiên cứu và tìm hiểu thì gRPC là một giải pháp khá tốt cho vấn đề này. nên hôm nay mình sẻ chia sẻ cho các bạn cách sử dụng gRPC trong Typescript.</p><p>Hẳn chúng ta ai cũng quen làm việc với các REST API. Tuy nhiên, trong môi trường microservice, việc sử dụng REST API để giao tiếp giữa các service sẽ gây ra độ trễ đáng kể. gRPC ra đời để giải quyết vấn đề này. Trong blog này mình sẽ trình bày nội dung cơ bản liên quan đến gRPC và làm một todo list app demo để chúng ta biết cách sử dụng gRPC trong thực tế nhé.</p><h2 id=\"gRPC-la-gi\"><a href=\"#gRPC-la-gi\" class=\"headerlink\" title=\"gRPC là gì ???\"></a>gRPC là gì ???</h2><p>gRPC là một RPC platform được phát triển bởi Google nhằm tối ưu hoá và tăng tốc việc giao tiếp giữa các service với nhau trong kiến trúc microservice.</p><p>gRPC dùng Protocal Buffer giảm kích thước request và response data, RPC để đơn giản hoá trong việc tạo ra các giao tiếp giữa các service với nhau, HTTP/2 để tăng tốc gửi/nhận HTTP request.</p><p>Có thể hiểu nôm na gRPC là tương tự như REST dùng để giao tiếp giữa các service, tuy nhiên tốc độ gRPC nhanh hơn REST rất nhiều, bù lại gRPC khó sử dụng và rườm rà hơn. Bạn chỉ nên sử dụng gRPC khi có vấn đề về độ trễ trong việc giao tiếp giữa các service trong kiến trúc microservice.</p><h3 id=\"Tai-sao-nen-su-dung-gRPC\"><a href=\"#Tai-sao-nen-su-dung-gRPC\" class=\"headerlink\" title=\"Tại sao nên sử dụng gRPC ???\"></a>Tại sao nên sử dụng gRPC ???</h3><p>Vấn đề là gì và tại sao cần nó ?</p><p>RPC có thể được xem là một giao thức request-respone thông thường tuy nhiên nó được dùng cho việc giao tiếp giữa các server với nhau (server-server) nhiều hơn là client-server. Việc này có ý nghĩa rất quan trọng vì trong các hệ thống phân tán (distributed system), application code ở nhiều server hơn là một server. Ví dụ thường thấy nhất chính là kiến trúc Microservices.</p><p>Điều này nghĩa là: một request phía client có thể sẽ phải cần nhiều service chạy trên các server này để tổng hợp thông tin rồi mới response cho client. Sự liên lạc giữa các server lúc này sẽ là vấn đề mà trước đó tất cả service chạy trên 1 server thì khoẻ re, vì local call nên chẳng ngại gì cả. Chính xác là khi đó, khi một server muốn “nói chuyện” với server khác sẽ cần phải encode data (JSON, XML), phía nhận cũng phải làm công việc ngược lại là decode data mới hiểu thằng kia nói gì với mình rôi lại phải encode lại tiếp. Việc này tiêu tốn khá nhiều tài nguyên xử lý (CPU) mà lẽ ra chỉ cần làm ở bước đầu và cuối (đầu nhận và trả về cuối cùng).</p><p>Tối ưu cho việc “giao tiếp” giữa các server là lý do gRPC ra đời.</p><p>Để giải bài toán trên, gRPC đã sử dụng binary để truyền đi thay vì phải encode chúng thành các ngôn ngữ trung gian JSON/XML. Việc này rõ ràng đã làm tăng tốc giao tiếp các servers lên rất nhiều, giảm overhead cho CPUs. Google cũng “tiện tay” làm luôn cả protobuf (protocol buffers), đây là ngôn ngữ mà gRPC dùng như một default serialization format. Implement phần này thật sự phải là tay to lắm nên Google xử dụng protobuf như một script trung gian để generate phần hard core cho các dev ở các ngôn ngữ phổ biến như: C++, C#, Go, Java, Pyhon.</p><p>Thứ giúp gRPC giao tiếp binary ngon vậy chính là http/2, đây vốn là giao thức có rất nhiều cải tiến so với http/1.1. Bản thân http/2 cũng được coi như là sự thay thế cho SPDY, giao thức mà cũng chính Google phát triển, open source vào 2012 và ngừng hỗ trợ vào 2015 (http/2 có implement và thay thế rồi).</p><p><a href=\"https://viblo.asia/p/grpc-no-la-gi-va-co-nen-su-dung-hay-khong-gDVK2mAj5Lj\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">Tham khảo thêm tại đây</a></p><h2 id=\"Xay-dung-gRPC-server-bang-Typescript\"><a href=\"#Xay-dung-gRPC-server-bang-Typescript\" class=\"headerlink\" title=\"Xây dựng gRPC server bằng Typescript\"></a>Xây dựng gRPC server bằng Typescript</h2><h3 id=\"Settup-mot-project-Typescript\"><a href=\"#Settup-mot-project-Typescript\" class=\"headerlink\" title=\"Settup một project Typescript\"></a>Settup một project Typescript</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir ts-grpc</span><br></pre></td></tr></table></figure><p>Khởi tạo một thư mục trống.</p><p>Và cấu trúc thư mục sẽ có dạng như sau.</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── dist/                            <span class=\"comment\"># Compiled files</span></span><br><span class=\"line\">├── src/                             <span class=\"comment\"># Source files</span></span><br><span class=\"line\">│   ├── handlers/                    <span class=\"comment\"># gRPC service handlers</span></span><br><span class=\"line\">|   │   └── greeter.ts               <span class=\"comment\"># Greeter service definitions</span></span><br><span class=\"line\">│   ├── proto/                       <span class=\"comment\"># Proto files</span></span><br><span class=\"line\">│   │   ├── greeter/                 <span class=\"comment\"># Greeter gRPC service</span></span><br><span class=\"line\">│   │   │   └── greeter.proto</span><br><span class=\"line\">│   │   ├── index.ts                 <span class=\"comment\"># Registers all the proto typescript definitions</span></span><br><span class=\"line\">│   └── server.ts                    <span class=\"comment\"># Bootstrap server, add middleware (logs, graphql...)</span></span><br><span class=\"line\">├── scripts/                         <span class=\"comment\"># Generation tools</span></span><br><span class=\"line\">│   └── protoc.sh                    <span class=\"comment\"># Script to generate protoc typescript definitions</span></span><br><span class=\"line\">└── ...</span><br></pre></td></tr></table></figure><p>bây giờ chúng ta tiến hành cài đặt các dependencies cần thiết</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm init -y</span><br><span class=\"line\">npm install grpc google-protobuf dotenv</span><br><span class=\"line\">npm install typescript @types/node @types/google-protobuf @types/dotenv --save-dev</span><br></pre></td></tr></table></figure><p>Đây là các package chúng ta cài</p><ul><li>grpc để dùng gRPC với Node.js</li><li>google-protobuf để dùng Protocol Buffers (.proto) với javascript</li><li>dotenv để load các biến môi trường từ file .env</li><li>TypeScript và các gói mở rộng của typescript để dịch các package trên</li></ul><p>Chúng ta sẽ khởi tạo project typescript với lệnh:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npx tsc --init</span><br></pre></td></tr></table></figure><p>Sau khi chạy lệnh này xong chúng ta sẽ có file <strong>tsconfig.json</strong> như sau:</p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"compilerOptions\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"outDir\"</span>: <span class=\"string\">\"./dist/\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"module\"</span>: <span class=\"string\">\"commonjs\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"noImplicitAny\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"allowJs\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"esModuleInterop\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"target\"</span>: <span class=\"string\">\"es6\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"sourceMap\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"include\"</span>: [<span class=\"string\">\"./src/**/*\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"exclude\"</span>: [<span class=\"string\">\"node_modules\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>bây giờ mở file <strong>greeter.proto</strong> thêm code sau đây</p><figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> greeter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The greeting service definition.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Sends a greeting</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">rpc</span> SayHello (HelloRequest) <span class=\"keyword\">returns</span> (HelloResponse)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The request message containing the user's name.</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">HelloRequest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The response message containing the greetings</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">HelloResponse</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> <span class=\"class\"><span class=\"keyword\">message</span> = 1;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure><p>Nó sẽ tạo ra một service SayHello có kiểu dữ liệu request là HelloRequest với một trường dữ liệu là name và trả về một response với kiểu dữ liệu là HelloResponse. Bạn có thể xem thêm cú pháp syntax về proto 3 tại đây <a href=\"https://developers.google.com/protocol-buffers/docs/proto\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">https://developers.google.com/protocol-buffers/docs/proto</a>.</p><h3 id=\"Generating-TypeScript-definitions\"><a href=\"#Generating-TypeScript-definitions\" class=\"headerlink\" title=\"Generating TypeScript definitions\"></a>Generating TypeScript definitions</h3><p>Bây giờ chúng ta sẽ tạo ra các TypeScript definitions hỗ trợ cho gRPC service được khai báo trong file proto. Chúng ta sẽ tiến hành dịch file <strong>greeter.proto</strong> thành các class typescript có thể hiểu và sử dụng.</p><p>Chúng ta sẽ cài thêm các dependencies:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install grpc-tools grpc_tools_node_protoc_ts --save-dev</span><br></pre></td></tr></table></figure><p>Here we installed few more dev dependencies</p><ul><li>grpc-tools tạo javascript files cho proto files</li><li>grpc_tools_node_protoc_ts tạo các file module typescript tương ứng d.ts</li></ul><p>Sau khi cài các package xong, chúng ta sẽ tiến hành viết bash script để dịch file src/proto/.proto. Mở file <strong>protoc.sh</strong> và thêm code sau.</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">BASEDIR=$(dirname <span class=\"string\">\"<span class=\"variable\">$0</span>\"</span>)</span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"string\">\"<span class=\"variable\">$&#123;BASEDIR&#125;</span>\"</span>/../</span><br><span class=\"line\"></span><br><span class=\"line\">PROTOC_GEN_TS_PATH=<span class=\"string\">\"./node_modules/.bin/protoc-gen-ts\"</span></span><br><span class=\"line\">GRPC_TOOLS_NODE_PROTOC_PLUGIN=<span class=\"string\">\"./node_modules/.bin/grpc_tools_node_protoc_plugin\"</span></span><br><span class=\"line\">GRPC_TOOLS_NODE_PROTOC=<span class=\"string\">\"./node_modules/.bin/grpc_tools_node_protoc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> ./src/proto/*; <span class=\"keyword\">do</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># skip the non proto files</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$(basename \"$f\")</span>\"</span> == <span class=\"string\">\"index.ts\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">      <span class=\"built_in\">continue</span></span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># loop over all the available proto files and compile them into respective dir</span></span><br><span class=\"line\">  <span class=\"comment\"># JavaScript code generating</span></span><br><span class=\"line\">  <span class=\"variable\">$&#123;GRPC_TOOLS_NODE_PROTOC&#125;</span> \\</span><br><span class=\"line\">      --js_out=import_style=commonjs,binary:<span class=\"string\">\"<span class=\"variable\">$&#123;f&#125;</span>\"</span> \\</span><br><span class=\"line\">      --grpc_out=<span class=\"string\">\"<span class=\"variable\">$&#123;f&#125;</span>\"</span> \\</span><br><span class=\"line\">      --plugin=protoc-gen-grpc=<span class=\"string\">\"<span class=\"variable\">$&#123;GRPC_TOOLS_NODE_PROTOC_PLUGIN&#125;</span>\"</span> \\</span><br><span class=\"line\">      -I <span class=\"string\">\"<span class=\"variable\">$&#123;f&#125;</span>\"</span> \\</span><br><span class=\"line\">      <span class=\"string\">\"<span class=\"variable\">$&#123;f&#125;</span>\"</span>/*.proto</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable\">$&#123;GRPC_TOOLS_NODE_PROTOC&#125;</span> \\</span><br><span class=\"line\">      --plugin=protoc-gen-ts=<span class=\"string\">\"<span class=\"variable\">$&#123;PROTOC_GEN_TS_PATH&#125;</span>\"</span> \\</span><br><span class=\"line\">      --ts_out=<span class=\"string\">\"<span class=\"variable\">$&#123;f&#125;</span>\"</span> \\</span><br><span class=\"line\">      -I <span class=\"string\">\"<span class=\"variable\">$&#123;f&#125;</span>\"</span> \\</span><br><span class=\"line\">      <span class=\"string\">\"<span class=\"variable\">$&#123;f&#125;</span>\"</span>/*.proto</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure><p>Phân quyền cho file <strong>protoc.sh</strong> bằng lệnh sau.</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo chmod +x ./scripts/protoc.sh</span><br></pre></td></tr></table></figure><p>Bây giờ chạy script trên và nó sẽ tao các javascript file trong src/proto/greeter. Mỗi khi chỉnh sửa proto file bạn hãy nhớ chạy lại lệnh này để update các javascript file.</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./scripts/protoc.sh</span><br></pre></td></tr></table></figure><p>Sau đó mở file <strong>src/proto/index.ts</strong> và thêm code sau</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./greeter/greeter_pb'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./greeter/greeter_grpc_pb'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> protoIndex: any = (): <span class=\"function\"><span class=\"params\">void</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>Nhớ là bạn luôn phải update file này khi tạo ra các proto file mới .</p><h3 id=\"Tao-handlers\"><a href=\"#Tao-handlers\" class=\"headerlink\" title=\"Tạo handlers\"></a>Tạo handlers</h3><p>Chúng ta sẽ viết hàm xử lý cho SayHello service, hãy mở src/handlers/greeter.ts thêm code này.</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> grpc <span class=\"keyword\">from</span> <span class=\"string\">'grpc'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; HelloRequest, HelloResponse &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./proto/greeter/greeter_pb'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  GreeterService,</span><br><span class=\"line\">  IGreeterServer,</span><br><span class=\"line\">&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./proto/greeter/greeter_grpc_pb'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreeterHandler</span> <span class=\"title\">implements</span> <span class=\"title\">IGreeterServer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">_ Greet the user nicely</span></span><br><span class=\"line\"><span class=\"comment\">_ <span class=\"doctag\">@param <span class=\"variable\">call</span></span></span></span><br><span class=\"line\"><span class=\"comment\">_ <span class=\"doctag\">@param <span class=\"variable\">callback</span></span></span></span><br><span class=\"line\"><span class=\"comment\">_</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">  sayHello = (</span><br><span class=\"line\">    call: grpc.ServerUnaryCall&lt;HelloRequest&gt;,</span><br><span class=\"line\">    callback: grpc.sendUnaryData&lt;HelloResponse&gt;</span><br><span class=\"line\">  ): <span class=\"function\"><span class=\"params\">void</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> reply: HelloResponse = <span class=\"keyword\">new</span> HelloResponse();</span><br><span class=\"line\"></span><br><span class=\"line\">    reply.setMessage(<span class=\"string\">`Hello, <span class=\"subst\">$&#123;call.request.getName()&#125;</span>`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    callback(<span class=\"literal\">null</span>, reply);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  service: GreeterService, <span class=\"comment\">// Service interface</span></span><br><span class=\"line\">  handler: <span class=\"keyword\">new</span> GreeterHandler(), <span class=\"comment\">// Service interface definitions</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>chúng ta sẽ thấy method sayHello được implement SayHello rpc service. lấy dữ liệu name từ request HelloRequest và chuyễn thành một câu chào kiểu HelloResponse và trả về</p><h3 id=\"Khoi-tao-server\"><a href=\"#Khoi-tao-server\" class=\"headerlink\" title=\"Khởi tạo server\"></a>Khởi tạo server</h3><p>Bây giờ chúng ta sẽ khởi tạo gRPC server. Mở file src/server.ts và thêm code:</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dotenv/config'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> grpc <span class=\"keyword\">from</span> <span class=\"string\">'grpc'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; protoIndex &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./proto'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> greeterHandler <span class=\"keyword\">from</span> <span class=\"string\">'./handlers/greeter'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">protoIndex();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> port: string | number = process.env.PORT || <span class=\"number\">50051</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">type StartServerType = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> startServer: StartServerType = (): <span class=\"function\"><span class=\"params\">void</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// create a new gRPC server</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> server: grpc.Server = <span class=\"keyword\">new</span> grpc.Server();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// register all the handler here...</span></span><br><span class=\"line\">  server.addService(greeterHandler.service, greeterHandler.handler);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// define the host/port for server</span></span><br><span class=\"line\">  server.bindAsync(</span><br><span class=\"line\">    <span class=\"string\">`0.0.0.0:<span class=\"subst\">$&#123;port&#125;</span>`</span>,</span><br><span class=\"line\">    grpc.ServerCredentials.createInsecure(),</span><br><span class=\"line\">    (err: <span class=\"built_in\">Error</span>, <span class=\"attr\">port</span>: number) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">`gRPC listening on <span class=\"subst\">$&#123;port&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// start the gRPC server</span></span><br><span class=\"line\">  server.start();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">startServer();</span><br></pre></td></tr></table></figure><p>Ok, chúng ta đã tạo ra các instance của greeter service, đăng ký greeter service handler và chạy server.</p><h3 id=\"Kiem-tra-xem-nao\"><a href=\"#Kiem-tra-xem-nao\" class=\"headerlink\" title=\"Kiểm tra xem nào\"></a>Kiểm tra xem nào</h3><p>Trước tiên mở file <strong>package.json</strong> thêm các lệnh sau vào phần script:</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"build\"</span>: <span class=\"string\">\"npx tsc --skipLibCheck\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span>: <span class=\"string\">\"npx tsc --skipLibCheck &amp;&amp; node ./dist/server.js\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><p>Ok chạy thử nào!!!</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run build</span><br><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure><p>Ok bây giờ chúng ta có một server gRPC chạy trên port 50051</p><p>Để test gRPC các bạn hãy dùng <strong>BloomRPC</strong> Đây là một GUI tương tữ như <strong>Postman</strong> nhưng dùng cho các api bằng gRPC. Để cài đặt các bạn xem hướng dẫn <a href=\"https://github.com/uw-labs/bloomrpc\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">tại đây</a>.</p><p><img src=\"https://i.imgur.com/bsvIC1U.png\" alt=\"\"></p><p>OK để test chúng ta hãy bắt đầu làm như sau, import greeter.proto file, đổi URL thành 127.0.0.1:50051 và click vào icon play để tận hưởng =]]]] chúc các bạn thành công.</p><p>Source code của bài viết này được cập nhật tại đây : <a href=\"https://github.com/ntpntp1997/gRPC-server-typescript\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">https://github.com/ntpntp1997/gRPC-server-typescript</a></p>","categories":["Framework","gRPC","TypeScript","NodeJs"],"tags":["TypeScript","gRPC"]},{"title":"Hướng dẫn xây dựng docker image cho NodeJs một cách tối ưu","url":"/Huong-dan-xay-dung-docker-image-cho-NodeJs-mot-cach-toi-uu/","content":"<h2 id=\"Tai-sao-ban-nen-su-dung-Docker\"><a href=\"#Tai-sao-ban-nen-su-dung-Docker\" class=\"headerlink\" title=\"Tại sao bạn nên sử dụng Docker?\"></a>Tại sao bạn nên sử dụng Docker?</h2><p>Khi công việc kinh doanh cần tới nhiều ứng dụng web khác nhau, khi mà bây giờ framework hay ngôn ngữ lập trình chỉ là công cụ. Các công ty không bị giới hạn và có thể sử dụng bất kỳ ngôn ngữ nào cần. Vì vậy chúng ta cần có một môi trường mà nhiều ứng dụng khác nhau có thể chạy cùng nhau trên đó.</p><p>Virtual Machines (VM) cho phép chúng ta chạy nhiều app trên cùng 1 server. Nhưng cũng có hạn chế. Mỗi VM cần toàn bộ OS để chạy. Mỗi OS lại cần CPU, RAM,… để chạy, rồi nó cần patching và licensing, do đó làm tăng chi phí và khả năng phục hồi.</p><p>Google bắt đầu sử dụng mô hình container từ lâu để giải quyết các thiếu sót của mô hình VM. Về cơ bản thì mô hình container có nghĩa là nhiều container trên cùng một máy chủ sử dụng cùng một máy chủ, giải phóng CPU, RAM để có thể được sử dụng ở nơi khác.</p><h2 id=\"Docker-rat-tot-vay-tai-sao-phai-toi-uu-docker-image\"><a href=\"#Docker-rat-tot-vay-tai-sao-phai-toi-uu-docker-image\" class=\"headerlink\" title=\"Docker rất tốt vậy tại sao phải tối ưu docker image ?\"></a>Docker rất tốt vậy tại sao phải tối ưu docker image ?</h2><p>Câu trả lời rất đơn giản: Là để tiết kiệm.<br>Tiết kiệm cái gì? Bất cứ cái gì gọi là tài nguyên và có thể tiết kiệm được thì chúng ta sẽ tiết kiệm. Ví dụ:</p><ul><li>Thời gian</li><li>Dung lượng lưu trữ</li><li>Tài nguyên chạy (CPU, RAM)</li><li>Băng thông</li></ul><p>Bây giờ 1 image bạn build ra, bạn phải mất thời gian build nó, mất dung lượng lưu trữ để chứa nó, tài nguyên để chạy nó, và băng thông để phân phối nó tới các máy chủ. Vậy tối ưu tức là tiết kiệm những thứ kể trên.</p><p>Nói thì nói vậy, tuy nhiên hầu hết chúng ta đều chả quan tâm đếch gì đến mấy cái thứ đó, vì nó không thực tế và gần gũi với những thứ chúng ta làm hàng ngày. Nhưng nếu bạn ở vào hoàn cảnh phải chờ đợi mòn mỏi 10 phút để đẩy hotfix lên server, bạn sẽ biết quý trọng thời gian, hay quản lý một hệ thống khoảng 50 container đang chạy, thì số tiền bạn bỏ ra cho việc phung phí tài nguyên là sẽ không nhỏ.</p><h2 id=\"Hien-trang\"><a href=\"#Hien-trang\" class=\"headerlink\" title=\"Hiện trạng\"></a>Hiện trạng</h2><p>Hãy bắt đầu với với hiện trạng của mình trước đây bằng 1 Dockerfile chạy <strong>NodeJS</strong> đơn giản.</p><script src=\"//gist.github.com/669fc326a1014db67c1f36f9d6a00780.js\"></script><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker image ls -a | grep app</span><br><span class=\"line\">app   lattest         c9bbbeb45eca        13 minutes ago      1.25GB</span><br></pre></td></tr></table></figure><p>Image này build mất 4 phút và nặng tới 1.25GB. Thật không thể tin được. Có gì đó sai sai ở đây rồi, ứng dụng của mình chỉ là một ứng dụng API chạy bằng expressjs hết sức nhẹ mà.</p><p>Chưa hết, mình thử thay đổi 1 file README.md trong project, sau đó thử build lại thì vẫn mất 3 phút (do không phải download lại base image). Image của mình được build lại toàn bộ, bắt nguồn từ dòng ADD . /app, bao gồm cả việc install dependencies, build app,… Trong khi README.md thì liên quan gì tới ứng dụng của mình đâu để phải mất bao nhiêu thời gian và tài nguyên build lại image như thế?</p><p>Hệ thống của mình còn chạy CI/CD nên với việc setup Dockerfile phía trên, mỗi lần chạy mình mất 15 phút để code có thể chạy được trên server. WTF?</p><h2 id=\"Ket-qua\"><a href=\"#Ket-qua\" class=\"headerlink\" title=\"Kết quả\"></a>Kết quả</h2><p>Sau 1 hồi tìm tòi học hỏi và tối ưu, giờ đây image app của mình chỉ nặng vỏn vẹn 150MB thay vì 1.25GB như trước, mất 1p30s để build lần đầu tiên, và chỉ 10s để build mỗi khi mình thay đổi code chút ít. Quá trình CI/CD cũng từ đó rút ngắn xuống 8 phútcho lần đầu tiên và chỉ 3 phút cho các thay đổi code sau này thay vì cứ đều như vắt chanh 15 phút 1 lần như trước.<br>Vậy mình đã làm gì?</p><h2 id=\"Toi-uu-the-nao\"><a href=\"#Toi-uu-the-nao\" class=\"headerlink\" title=\"Tối ưu thế nào?\"></a>Tối ưu thế nào?</h2><p>Giờ khi đã hiểu tại sao phải tối ưu, ta bước đến bước khó khăn hơn là tối ưu thế nào. Đây là một số bước chính mình đã làm để có thể tối ưu được quá trình build này. Ngoài ra còn 1 vài cái lặt vặt nữa như remove file tạm,… thì tạm không nhắc tới.</p><h2 id=\"Thay-doi-base-image\"><a href=\"#Thay-doi-base-image\" class=\"headerlink\" title=\"Thay đổi base image\"></a>Thay đổi base image</h2><p>Đây là bước đầu tiên và quan trọng nhất, trừ khi hoàn cảnh không cho phép hoặc image không có sẵn, nếu không hãy luôn sử dụng image được dựng trên alpine. Đây là những base image nhẹ nhất, tối ưu nhất cho việc lưu trữ mà vẫn đủ điều kiện để app của chúng ta chạy ngon lành.</p><p>Thay vì sử dụng FROM node:10, mình đã chuyển qua sử dụng FROM node:10-alpine</p><p>Các image dựng trên alpine có dung lượng rất nhẹ, với nodejs là giảm từ 900MB của bản mặc định xuống chỉ còn 70MB của alpine.</p><p>Điểm trừ duy nhất của alpine đó là việc nó quá nhỏ gọn nên bạn phải tự túc cài thêm những thư viện bạn cần dùng. Và việc này với những người mới là khá rắc rối đó nhé.</p><h2 id=\"Tan-dung-layer-caching\"><a href=\"#Tan-dung-layer-caching\" class=\"headerlink\" title=\"Tận dụng layer caching\"></a>Tận dụng layer caching</h2><p>Layer caching là một tính năng rất quan trọng giúp giảm thời gian của quá trình build bằng cách tận dụng những layer đã được build từ lần trước đó (với điều kiện không có thay đổi trong chỉ định build). Để có thể tận dụng tối đa tính năng này, ta cần sắp xếp lại và tách lệnh build sao cho phần lệnh ít thay đổi sẽ ở trên, phần thay đổi thường xuyên sẽ ở dưới.</p><p>Đây là điều mình đã làm với Dockerfile trên:</p><script src=\"//gist.github.com/409bf4999d05fa6b07eca5d549d75819.js\"></script><p>Mình đã chuyển EXPOSE 3000 lên trên cùng với WORKDIR /app, tách phần ADD . /app ra để thêm 1 chỉ định ADD package.json yarn.lock /app/. Do 2 file package.json và yarn.lock chứa thông tin về những package mình dùng nhưng lại ít thay đổi, do đó đẩy nó lên trên sẽ giúp việc cài đặt dependencies từ npm có thể sử dụng lại từ image đã build từ trước.</p><p><strong>Tips: Sắp xếp các lệnh build theo sự thay đổi thường xuyên tăng dần</strong></p><h2 id=\"Giam-bot-so-luong-layer\"><a href=\"#Giam-bot-so-luong-layer\" class=\"headerlink\" title=\"Giảm bớt số lượng layer\"></a>Giảm bớt số lượng layer</h2><p>Như chúng ta đều đã biết, docker image được dựng nên từ những layer xếp chồng lên nhau, mỗi layer được tạo ra từ các câu lệnh chúng ta viết trong Dockerfile. Càng nhiều layer thì image của chúng ta càng nặng nề. Chính vì vậy việc giảm thiểu tối đa số lượng layer chính là cách để tối ưu dung lượng image.</p><p>Có 3 câu lệnh sẽ tạo ra các layer mới là RUN, COPY và ADD, nên việc gộp lệnh này chỉ có tác dụng với 3 lệnh này nhé. Trong ví dụ trên, mình đã gộp những câu lệnh sau thành 1 lệnh, do đó chỉ tạo ra 1 layer duy nhất:</p><script src=\"//gist.github.com/e0b904e351e6dc7ce15e2647cd8eaa2f.js\"></script><p>Một lưu ý khi các bạn ứng dụng biện pháp này, đó chính là việc gộp lại thành 1 dòng sẽ làm mất đi ưu thế của caching layer khi build. Bạn đâu muốn chỉ vì một thay đổi nhỏ mà dẫn tới image bị build lại từ những bước đầu chả liên quan đúng không? Do vậy trước ghi gộp, hãy tính tới những thay đổi bạn có thể tạo ra cho ứng dụng, và tối ưu việc caching layer cần được ưu tiên hơn.</p><h2 id=\"Toi-uu-dockerignore\"><a href=\"#Toi-uu-dockerignore\" class=\"headerlink\" title=\"Tối ưu .dockerignore\"></a>Tối ưu .dockerignore</h2><p>Như mình đã nói trong 1 số bài viết khác, file .dockerignore sinh ra với mục đích báo cho docker biết để loại trừ những file này ra khỏi build context, tức là loại ra khỏi những file mà docker định dùng để build image.</p><p>Để tránh việc bạn sửa 1 file README.md chả liên quan mà cũng khiến image của bạn phải build lại, hãy thêm nó vào .dockerignore. Sau đây là 1 số loại file nên đưa vào .dockerignore</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Environment variables</span></span><br><span class=\"line\">.env</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Logs</span></span><br><span class=\"line\">logs</span><br><span class=\"line\">*.<span class=\"built_in\">log</span></span><br><span class=\"line\">npm-debug.log*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Documentation</span></span><br><span class=\"line\">docs</span><br><span class=\"line\">*.md</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Coverage directory used by tools like istanbul</span></span><br><span class=\"line\">coverage</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># nyc test coverage</span></span><br><span class=\"line\">.nyc_output</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)</span></span><br><span class=\"line\">.grunt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># node-waf configuration</span></span><br><span class=\"line\">.lock-wscript</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Dependency directories</span></span><br><span class=\"line\">node_modules</span><br><span class=\"line\">jspm_packages</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Optional npm cache directory</span></span><br><span class=\"line\">.npm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Optional REPL history</span></span><br><span class=\"line\">.node_repl_history</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Dist folder (code after build)</span></span><br><span class=\"line\">dist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Project file</span></span><br><span class=\"line\">*.sublime-project</span><br><span class=\"line\">*.sublime-workspace</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Git file</span></span><br><span class=\"line\">.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Docker file</span></span><br><span class=\"line\">*Dockerfile*</span><br><span class=\"line\">*docker-compose*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Deploy folder and file</span></span><br><span class=\"line\">deploy</span><br><span class=\"line\">.gitlab-ci.yml</span><br></pre></td></tr></table></figure><h2 id=\"Su-dung-multi-stage-build\"><a href=\"#Su-dung-multi-stage-build\" class=\"headerlink\" title=\"Sử dụng multi-stage build\"></a>Sử dụng multi-stage build</h2><p>Đây là phương pháp cuối cùng mình đề cập trong bài viết này. Multi-stage build được giới thiệu từ docker v17.05, là một cách rất mới để các bạn tối ưu được runtime image của mình bằng việc loại bỏ đi toàn bộ những thứ được sinh ra trong quá trình install, build code,… nhưng lại không cần thiết cho quá trình chạy ứng dụng. Trở lại với ví dụ trong bài, mình sẽ tách image cũ thành 2 image trên một Dockerfile như sau:</p><script src=\"//gist.github.com/a72188859b94ef68b527b2dbcf3eaabf.js\"></script><p>Với việc tách image như thế này. Image runtime của mình chỉ nặng 160MB mà không phải là 400MB như việc chỉ sử dụng 1 image.</p><p>Tuy nhiên cái lợi nào cũng đi cùng cái giá của nó. Chúng ta có thể giảm được dung lượng runtime image, nhưng lại mất đi 1 tính năng hết sức quan trọng là layer caching. Việc docker chỉ lưu lại image kết quả cuối cùng mà không lưu builder image làm toàn bộ công tách rồi ghép lệnh của chúng ta đổ sông đổ bể.</p><p>Nhưng các bạn đừng vội bảo mình tại sao lại xúi bạn tách ghép lệnh làm gì. Việc gì khó cũng có cách giải quyết, chỉ là nó hơi mất công 1 chút. Chúng ta hoàn toàn có thể lưu lại được builder image và dùng nó làm cache cho lần build sau bằng 1 lệnh build kèm –target như sau:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker build -t app:builder --target=builder .</span><br></pre></td></tr></table></figure><p>Chỉ định –target sẽ giúp quá trình build dừng lại ở bước builder, từ đó chúng ta sẽ có 1 image builder ngon nghẻ để cache cho lần sau rồi.</p><p>Tips: Multi stage build giúp tiết kiệm tài nguyên cho quá trình runtime, nhưng lại tốn thêm tài nguyên lưu trữ thời gian trong quá trình build. Tuy nhiên từ kinh nghiệm cá nhân của mình thì việc này hoàn toàn xứng đáng đánh đổi.</p><h2 id=\"Ngoai-le-ve-cach-quan-ly-microservice-image\"><a href=\"#Ngoai-le-ve-cach-quan-ly-microservice-image\" class=\"headerlink\" title=\"Ngoài lề về cách quản lý microservice image\"></a>Ngoài lề về cách quản lý microservice image</h2><p>Đến đây coi như mình đã nói xong với các bạn về cách tối ưu docker image trong prodcution phục vụ cả quá trình build và runtime. Tiện thể mình sẽ chia sẻ luôn về cách mình quản lý mấy chục image hiện tại của sản phẩm.</p><p>Các bạn nếu đã làm microservice, nhất là với số lượng lớn đều sẽ nhận thấy một vấn đề đó chính là việc quản lý image của toàn bộ các microservice là rất mất thời gian và vất vả. Với khoảng 20 microservice, trong đó có 17 service backend và 3 service frontend thì số lượng image na ná nhau là rất nhiều.</p><p>Giả sử bạn muốn thêm vào toàn bộ các image backend một file chứa thời gian image đó được build chẳng hạn. Khi đó bạn sẽ phải sửa lại 17 project backend chỉ để copy paste lại đúng 1 dòng. Nghe nản không?</p><p>Rất may là docker có giới thiệu một chỉ thị có tên là ONBUILD. Doc của nó <a href=\"https://docs.docker.com/engine/reference/builder/#onbuild\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">tại đây</a>. Vậy ONBUILD có tác dụng gì trong trường hợp này?</p><p>ONBUILD là chỉ thị tạo ra 1 trigger, nôm na là 1 điểm chờ. Khi mình build image X có chứa chỉ thị ONBUILD thì lệnh phía sau ONBUILD sẽ không được thực thi mà sẽ chờ đợi. Cho đến khi image X được dùng làm base image cho 1 image khác thì lệnh sau ONBUILD mới được thực thi.</p><p>Ví dụ:</p><script src=\"//gist.github.com/9306d132926f5571127279f0ad86b0b7.js\"></script><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker build -t <span class=\"built_in\">test</span> .</span><br><span class=\"line\">Sending build context to Docker daemon  2.048kB</span><br><span class=\"line\">Step 1/3 : FROM node:10-alpine</span><br><span class=\"line\"> ---&gt; df48b68da02a</span><br><span class=\"line\">Step 2/3 : ONBUILD ADD package.json yarn.lock /app/</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 91fb4e71156f</span><br><span class=\"line\">Removing intermediate container 91fb4e71156f</span><br><span class=\"line\"> ---&gt; efb9bf8fe2a9</span><br><span class=\"line\">Step 3/3 : ONBUILD RUN yarn --pure-lockfile</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 22441a427546</span><br><span class=\"line\">Removing intermediate container 22441a427546</span><br><span class=\"line\"> ---&gt; 9a57cb7773e0</span><br><span class=\"line\">Successfully built 9a57cb7773e0</span><br><span class=\"line\">Successfully tagged <span class=\"built_in\">test</span>:latest</span><br></pre></td></tr></table></figure><p>Như các bạn thấy, trong image test mình vừa build không hề có file package.json hay yarn.lock nào cả, chỉ là một lệnh chờ đợi được tạo ra mà thôi.<br>Giờ trong project code của mình thì Dockerfile mình sẽ viết:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure><p>Và đây là kết quả khi build</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker build -t app .</span><br><span class=\"line\">Sending build context to Docker daemon  513.5kB</span><br><span class=\"line\">Step 1/1 : FROM builder</span><br><span class=\"line\"><span class=\"comment\"># Executing 2 build triggers</span></span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 775275b026e1</span><br><span class=\"line\">yarn install v1.9.4</span><br><span class=\"line\">Done <span class=\"keyword\">in</span> 29.47s.</span><br><span class=\"line\">Removing intermediate container 775275b026e1</span><br><span class=\"line\"> ---&gt; 1903e4902d84</span><br><span class=\"line\">Successfully built 1903e4902d84</span><br><span class=\"line\">Successfully tagged app:latest</span><br></pre></td></tr></table></figure><p>Và cho tới lúc này, 2 lệnh mà mình cần là ADD package.json yarn.lock /app/ và RUN yarn –pure-lockfile mới thật sự được thực thi. Vậy là trong project của mình không cần phải định nghĩa lại Dockerfile nữa, chỉ việc sử dụng 1 template do mình tạo ra cho toàn bộ các service là được.</p><p>Điều này giúp tiết kiệm thời gian maintain toàn bộ mấy chục service image, cũng giúp mình tiết kiệm thời gian build, do những thứ lặp đi lặp lại như việc cài đặt môi trường đã được lưu trong image template rồi.</p><h2 id=\"Ket-luan\"><a href=\"#Ket-luan\" class=\"headerlink\" title=\"Kết luận\"></a>Kết luận</h2><p>Để tối ưu các bạn nên quan tâm đến 6 điều nàyL</p><ul><li>Chọn base image trên nền alpine để dung lượng tối ưu nhất</li><li>Sắp xếp Dockerfile để tận dụng layer caching giúp giảm thời gian build</li><li>Gộp các câu lệnh RUN, ADD, COPY có liên quan với nhau để giảm số layer mới</li><li>Tối ưu .dockerignore file để loại bỏ những file không cần thiết trong quá trình build image</li><li>Sử dụng multi-stage build để giảm dung lượng runtime image</li><li>Dùng chung image template bằng việc sử dụng ONBUILD cho base image giúp tiết kiệm công sức quản lý và thời gian build.<br>Cám ơn các bạn đã đọc hết bài viết của mình!</li></ul><p>Nguồn tham khảo : <a href=\"https://topdev.vn/blog/docker-image-in-production-cau-chuyen-1gb-hay-100mb/\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">TopDev</a></p>","categories":["Docker"],"tags":["Nodejs","Docker"]},{"title":"Hướng dẫn xây dựng một trang blog cá nhân đơn giản bằng Hexo và deploy lên github","url":"/Huong-dan-xay-dung-mot-trang-blog-ca-nhan-don-gian-bang-Hexo-va-deploy-len-github/","content":"<p>Chuyện tạo ra một trang blog bằng các opensource CMS như wordpress, ghost, joomla… bây giờ là quá dễ dàng, nhanh gọn. Nhưng nó cũng có một số khuyết điểm của nó: như cồng kềnh, hay nếu không được tối ưu tốt sẽ gây ra hậu quả nặng site vân vân và mây mây …</p><p>Hầu hết các trang web trên mạng internet chúng ta truy cập mỗi ngày, chúng đều được tạo ra dynamic. Nghĩa là nội dung sẽ được lưu trữ trong database. Khi có người truy cập, server sẽ thực hiện quá trình load data và render HTML.</p><p>Cũng có rất nhiều trang web tạo ra static thay vì dynamic. Bởi vì những ưu điểm static website mang lại rất lớn cho các trang web với nhu cầu cơ bản như blog, trang giới thiệu công ty, hay một website cá nhân. Tuy nhiên static website cũng mang trong mình nhiều vấn đề bất cập. Cụ thể trong trường hợp chúng ta muốn đổi layout, đổi theme thì phải làm sao? Đối với một static website xây dựng bằng cách tự soạn HTML thủ công để làm được việc này rất tốn công. Chúng ta phải ngồi và update lại từng HTML một, giả dụ trang blog của bạn có 1000 bài viết bạn sẽ phải sửa 1000 tệp tin HTML. Nhưng bạn vẫn thích static website bởi vì lợi ích quá lớn, và như cầu của bạn cũng không cần nhiều. Bạn chỉ cần một blog đơn giản để thỏa mãn đam mê viết lách mỗi ngày mà thôi. Vậy thì static site generators chính là giải pháp tối ưu dành cho bạn.</p><p>Hôm nay mình sẽ hướng dẫn các bạn cách làm một trang blog cá nhân bằng Static website generator.<br>Bài viết này mình sẽ sử dụng Hexo và GitHub làm hướng dẫn và deploy.</p><h2 id=\"Hexo-static-website-danh-rieng-cho-viet-blog\"><a href=\"#Hexo-static-website-danh-rieng-cho-viet-blog\" class=\"headerlink\" title=\"Hexo static website dành riêng cho viết blog\"></a>Hexo static website dành riêng cho viết blog</h2><p>Hexo được tạo ra bằng Node.js và với mục đích chính dùng cho trang blog. Giống với rất nhiều static site generators khác, bạn cũng sẽ soạn thảo nội dung với markdown. Template mặc định được Hexo sử dụng chính là Swig. Swig không còn xa lạ gì đối với một lập trình viên JS. Tuy nhiên bạn cũng có thể sử dụng một template engine khác nếu muốn, Hexo cho phép bạn làm được điều này. So với Jekyll hoặc Hugo thì Hexo có đôi chút phức tạp hơn.</p><h3 id=\"Yeu-cau\"><a href=\"#Yeu-cau\" class=\"headerlink\" title=\"Yêu cầu\"></a>Yêu cầu</h3><ul><li>Nodejs 8 trở lên. Bạn có thể cài nodejs tại <a href=\"https://nodejs.org\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">https://nodejs.org</a> và tìm các phiên bản phù hợp. Mình đang dùng phiên bản Nodejs 12</li></ul><h2 id=\"Cai-dat\"><a href=\"#Cai-dat\" class=\"headerlink\" title=\"Cài đặt\"></a>Cài đặt</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id=\"Tao-blog-run-local\"><a href=\"#Tao-blog-run-local\" class=\"headerlink\" title=\"Tạo blog run local\"></a>Tạo blog run local</h3><p>Tạo một thư mục chứa blog của bạn, tại thư mục này chạy lệnh sau để khởi tạo một blog hexo:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure><p>Chạy blog ở local:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure><p>Mở trình duyệt và truy cập địa chỉ <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">http://localhost:4000</a> để xem kết quả!</p><h3 id=\"Viet-bai-va-public\"><a href=\"#Viet-bai-va-public\" class=\"headerlink\" title=\"Viết bài và public\"></a>Viết bài và public</h3><p>Phần liên quan nhất tới viết blog, viết ở đâu, ra sao? Hexo hỗ trợ viết bài với định dạng markdown. Khi tạo bài viết mới bằng lệnh:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"hello world\"</span></span><br></pre></td></tr></table></figure><p>Hexo sẽ sinh ra 1 file mang tên hello-world.md ở thư mục /source/_post và thư mục chứa assest của post đó là /source/_post/hello-world/.<br>Để có thể viết bài thì bạn chỉ cần mở file .md đó bằng bất cứ trình soạn thảo markdown nào cũng được hoặc là notepad++ =))<br>Bạn nên xem qua hướng dẫn trên trang chủ của hexo về format viết bài.<br>Bản chất thì hexo sẽ sinh ra file .html tĩnh tương ứng với bài viết .md của bạn.</p><h3 id=\"Hexo-theme\"><a href=\"#Hexo-theme\" class=\"headerlink\" title=\"Hexo theme\"></a>Hexo theme</h3><p>Bất cứ Blog framework nào cũng sẽ hỗ trợ theme cho bạn lựa chọn. Hexo cũng vậy, có một tá theme ở đây. Hầu như các theme ở đấy đều miễn phí và mã nguồn mở trên github.</p><p>Cài đặt theme ra sao? Thư mục theme ở /thư mục gốc/themes. Trong thư mục này mỗi thư mục con là một theme. Vậy nên để cài đặt theme mới thì việc đầu tiên là bạn phải clone code theme đó vào thư mục themes của Hexo. Ví dụ mình sử dụng theme cactus thì thư mục sẽ như sau:</p><p>Cấu hình để Hexo nhận theme vừa tải về như sau: giả sử bạn vừa tải về theme cactus. Bây giờ mở file _config.yml trong thư mục blog ra. Sử dòng cấu hình theme thành như sau:</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class=\"line\">#theme: landscape</span><br><span class=\"line\">theme: cactus</span><br></pre></td></tr></table></figure><p>Ok. Chạy lại hexo server để xem kết quả!<br>Lưu ý, một điều rất hay ở đây là hexo tách mỗi theme ra thành một project riêng, có package.json riêng, có _config.yaml riêng vì thế rất rõ ràng và tiện lợi, nếu bạn cài đặt theme khác thì chú ý tài liệu của theme để cấu hình theme cho đúng nhé.</p><h3 id=\"Dang-ky-Github-Pages\"><a href=\"#Dang-ky-Github-Pages\" class=\"headerlink\" title=\"Đăng ký Github Pages\"></a>Đăng ký Github Pages</h3><p>Đăng ký Github Pages cực kỳ đơn giản, bạn đăng ký một tài khoản github vd: ntpntp1997. Thì blog của bạn sẽ có địa chỉ truy cập là <a href=\"http://ntpntp1997.github.io\">http://ntpntp1997.github.io</a>. Chi tiết xem hướng dẫn trên trang chủ Github Pages.</p><p>Sinh web tĩnh và deploy lên github pages<br>Giả sử bạn đã đăng ký được github page. Bây giờ ta sẽ tạo web tĩnh từ Hexo và deploy lên Github Pages.<br>Hexo cung cấp một file cấu hình _config.yml ở thư mục gốc của blog. Tại thư mục này ta cấu hình để deploy như sau:</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">    type: git</span><br><span class=\"line\">    repo: https:&#x2F;&#x2F;github.com&#x2F;ntpntp1997&#x2F;ntpntp1997.github.io.git</span><br></pre></td></tr></table></figure><p>Ta chỉ ra rằng sẽ deploy bằng git và nơi sẽ deploy là repo <a href=\"https://github.com/ntpntp1997/ntpntp1997.github.io.git\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\">https://github.com/ntpntp1997/ntpntp1997.github.io.git</a><br>Cài đặt thư viện hexo-deployer-git để có thể deploy:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git -save</span><br></pre></td></tr></table></figure><p>Cuối cùng thực hiện deploy bằng lệnh sau:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure><p>Lúc này Hexo sẽ sinh web tĩnh ra và push lên repo của chúng ta đa đăng ký. Xong, bây giờ blog của chúng ta đã có trên github page và có thể truy cập được rồi.<br>Rất đơn giản phải không!</p><p>Nên nhớ bạn sẽ phải chạy lệnh generate lại sau mỗi khi thêm bài viết hay chỉnh sửa theme lại để hexo tạo ra các file web tĩnh mới và deploy lại, nó sẽ như thế này:</p><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate // generate lại static web</span><br><span class=\"line\">$ hexo deploy</span><br><span class=\"line\">// hoặc ngắn gọn hơn là</span><br><span class=\"line\">$ hexo generate -d</span><br></pre></td></tr></table></figure><p>Vậy là bài viết của mình đã xong rồi. Trong các bài viết sau mình sẽ hướng dẫn các bạn cách làm 1 theme website cho Hexo. Nếu mọi người có hứng thú với các framework static website generator khác mình sẽ làm bài viết về các framework đó cho các bạn :)))))</p><p>Trang blog này của mình cũng sử dụng hexo để làm. Cám ơn các bạn đã theo dõi bài viết của mình !!!</p>","categories":["Framework","Developer"],"tags":["GitHub","Hexo"]}]